# 검증 헤더와 조건부 요청

### 캐시시간 초과
* 캐시 유효시간이 초과해 서버에 다음 요청 시 두가지 상황이 있음.
  * 서버에서 기존 데이터 변경
  * 서버에서 기존 데이터 변경하지 않음
* 만약 서버에서 기존 데이터가 변경되지 않았다면 브라우저에 있는 캐시를 계속 사용해도 될 것 같음.
* 대신 변경되지 않았다는 확인을 할 수 있는 방법이 필요.

### 검증 헤더
캐시 데이터와 서버 데이터가 같은지 검증하는 데이터
* Last-Modified
* ETag

### 조건부 요청 헤더
검증헤더로 조건에 따른 분기
* If-Modified-Since - Last-Modified와 함께 사용
* If-None-Match - ETag 사용
* 조건 만족 시 200 OK
* 조건 불만족 시 304 Not Modified

#### Last-Modified

1. 서버에 데이터 요청
2. 서버는 cache-control 외에도 Last-Modified 추가
3. 브라우저 캐시에 캐시 유효값과 데이터 최종 수정일 추가 
4. 유효시간 초과 시 서버에 데이터를 다시 요청하고, 이때 if-modified-since 를 헤더에 넣어서 서버에 요청 (데이터 최종 수정일)
5. 서버에서는 넘어온 날짜를 통해 데이터 최종 수정일 비교 
6. 서버는 비교 후 수정된게 없으면 304 Not Modified 응답값 제공.
   * 이 때 cache-control과 Last-Modified는 헤더에 다시 넣어 제공하지만 바디는 없음. (수정된게 없으므로)
7. 이렇게 응답 시 헤더만 넘어오므로 네트워크 부하가 줄어듦. 
8. 브라우저는 응답결과를 제사용 하고 헤더 데이터 갱신.

데이터 미 변경 시 304 Not Modified - if-modified-since의 false 이므로.\
반대로 데이터 변경 시엔 200 OK 로 새로운 데이터를 받아옴.

### 정리
* 캐시 유효시간이 초과해도 서버 데이터가 그대로라면 304 응답 + 헤더만 응답으로 전달
* 클라이언트는 서버가 보낸 응답헤더로 캐시 메타정보 갱신
* 데이터는 기존 데이터 그대로 사용
* 네트워크 다운로드는 발생하지만 헤더만 갱신하므로 실용적인 해결방법임.

#### 단점
* 0.1초 단위 캐시 조정 불가능 (마지막 단위가 1초 단위)
* 날짜 기반 로직
* 데이터는 동일한데 날빠가 최신날짜로 변경될 경우 데이터를 받아옴.(날짜 기반)
* 서버에서 별도의 캐시로직을 관리하지 못함.

#### ETag
* Entity Tag
* 캐시용 데이터에 임이의 고유 버전을 달아둠.
* 데이터 변경 시 이 이름을 바꾸어 변경.
* 날짜 대신 ETag를 보내 같으면 유지, 다르면 변경.

1. 서버에 데이터 요청
2. 서버는 ETag 값을 헤더에 넣어 전달
3. 브라우저 캐시에 ETag 헤더 및 cache-control 값 추가.
4. 유효시간 초과 시 서버에 데이터를 다시 요청하고, 이때 If-None-Match 를 헤더에 넣어서 서버에 요청 (데이터 태그 수정여부)
5. 서버에서는 넘어온 태그값을 비교
6. 서버는 비교 후 태그값이 동일하면 304 Not Modified 응답값 제공.
7. 브라우저는 응답결과를 제사용 하고 헤더 데이터 갱신.

#### 정리
* ETag 를 서버에 보내서 같으면 유지, 다르면 변경
* 캐시 제어로직을 서버에서 관리
* 클라이언트는 단순하게 값만 서버에 제공